"""
Modern Pydantic models for structured email classification
Uses PydanticAI for guaranteed structured output from Qwen 2.5
"""

from typing import Literal, Optional
from pydantic import BaseModel, Field, ConfigDict
from datetime import datetime


class ContactHistory(BaseModel):
    """Contact history analysis for the sender"""
    sender_frequency_score: float = Field(
        ..., 
        ge=0.0, 
        le=1.0,
        description="How frequently this sender emails (0.0=rare, 1.0=very frequent)"
    )
    response_likelihood: float = Field(
        ..., 
        ge=0.0, 
        le=1.0,
        description="Likelihood of response based on historical patterns"
    )
    relationship_strength: float = Field(
        ..., 
        ge=0.0, 
        le=1.0,
        description="Overall relationship strength with this sender"
    )
    total_emails: int = Field(
        ..., 
        ge=0,
        description="Total number of emails from this sender"
    )
    recent_emails: int = Field(
        ..., 
        ge=0,
        description="Number of emails from this sender in last 30 days"
    )


class EmailClassification(BaseModel):
    """
    Multi-dimensional email classification with contact history context
    Generated by Qwen 2.5 with structured output validation
    """
    model_config = ConfigDict(str_strip_whitespace=True)
    
    # Basic classification
    classification: Literal["human", "promotional", "transactional", "automated"] = Field(
        ...,
        description="Primary email type classification"
    )
    confidence: float = Field(
        ..., 
        ge=0.0, 
        le=1.0,
        description="Confidence score for the primary classification"
    )
    
    # Multi-dimensional analysis
    sentiment: Literal["positive", "neutral", "negative"] = Field(
        ...,
        description="Overall sentiment of the email content"
    )
    sentiment_score: float = Field(
        ..., 
        ge=-1.0, 
        le=1.0,
        description="Sentiment intensity (-1.0=very negative, 0.0=neutral, 1.0=very positive)"
    )
    
    formality: Literal["formal", "informal", "casual", "neutral"] = Field(
        ...,
        description="Formality level of the email"
    )
    formality_score: float = Field(
        ..., 
        ge=0.0, 
        le=1.0,
        description="Formality intensity (0.0=very casual, 1.0=very formal)"
    )
    
    personalization: Literal["highly_personal", "somewhat_personal", "generic"] = Field(
        ...,
        description="Level of personalization in the email"
    )
    personalization_score: float = Field(
        ..., 
        ge=0.0, 
        le=1.0,
        description="Personalization intensity (0.0=generic, 1.0=highly personal)"
    )
    
    priority: Literal["urgent", "normal", "low"] = Field(
        ...,
        description="Priority level based on content and context"
    )
    priority_score: float = Field(
        ..., 
        ge=0.0, 
        le=1.0,
        description="Priority intensity (0.0=low priority, 1.0=urgent)"
    )
    
    # Processing recommendations
    should_process: bool = Field(
        ...,
        description="Whether this email should undergo full content processing"
    )
    processing_priority: int = Field(
        ..., 
        ge=0, 
        le=100,
        description="Processing priority (0=skip, 100=highest priority)"
    )
    
    # Analysis metadata
    reasoning: str = Field(
        ...,
        max_length=500,
        description="Brief explanation of the classification reasoning"
    )
    content_length: int = Field(
        ..., 
        ge=0,
        description="Length of the email content analyzed"
    )
    processing_time_ms: float = Field(
        default=0.0, 
        ge=0.0,
        description="Time taken for classification in milliseconds"
    )


class EmailProcessingRequest(BaseModel):
    """Request model for email classification"""
    email_id: str = Field(..., description="Unique email identifier")
    sender: str = Field(..., description="Email sender address")
    subject: Optional[str] = Field(None, description="Email subject line")
    content: str = Field(..., min_length=1, description="Email content to classify")
    contact_history: Optional[ContactHistory] = Field(
        None, 
        description="Historical context about the sender"
    )


class EmailProcessingResponse(BaseModel):
    """Response model for email classification"""
    email_id: str
    classification: EmailClassification
    contact_history: ContactHistory
    success: bool = True
    error: Optional[str] = None
    timestamp: datetime = Field(default_factory=datetime.utcnow)


class BatchProcessingRequest(BaseModel):
    """Request model for batch email classification"""
    emails: list[EmailProcessingRequest] = Field(
        ..., 
        min_length=1, 
        max_length=10,
        description="Batch of emails to classify (max 10)"
    )


class BatchProcessingResponse(BaseModel):
    """Response model for batch email classification"""
    results: list[EmailProcessingResponse]
    total_processed: int
    successful: int
    failed: int
    total_time_ms: float


class ThreadSummary(BaseModel):
    """Thread-level summary for notifications and UI"""
    thread_id: str
    summary_oneliner: str = Field(
        ..., 
        max_length=80,
        description="One-line summary suitable for notifications (10-15 words)"
    )
    key_entities: list[str] = Field(
        default_factory=list,
        description="Important people, topics, dates mentioned"
    )
    thread_mood: Literal["planning", "urgent", "social", "work", "problem_solving", "informational"] = Field(
        default="informational",
        description="Overall thread mood/purpose"
    )
    action_items: list[str] = Field(
        default_factory=list,
        max_length=5,
        description="Up to 5 action items extracted from conversation"
    )
    confidence: float = Field(
        ..., 
        ge=0.0, 
        le=1.0,
        description="Confidence in the summary quality"
    )
    last_email_count: int = Field(
        ..., 
        ge=1,
        description="Number of emails when this summary was generated"
    )


class ThreadSummaryRequest(BaseModel):
    """Request for generating thread summary"""
    thread_id: str
    emails: list[str] = Field(
        ...,
        min_length=1,
        max_length=20,
        description="List of email contents (max 20 most recent)"
    )
    existing_summary: Optional[str] = Field(
        None,
        description="Previous summary to update (if any)"
    )


# Prompts for Qwen 2.5
CLASSIFICATION_SYSTEM_PROMPT = """You are an expert email classifier. Analyze emails and provide detailed, multi-dimensional classification.

Consider these factors:
1. **Classification**: Is this human conversation, promotional content, transactional email, or automated message?
2. **Sentiment**: What's the emotional tone - positive, neutral, or negative?
3. **Formality**: How formal is the language - formal, informal, casual, or neutral?
4. **Personalization**: Is this highly personal, somewhat personal, or generic?
5. **Priority**: Based on content and urgency indicators - urgent, normal, or low?

For processing recommendations:
- Human conversations with high personalization should be processed
- Urgent emails should always be processed regardless of type
- Generic promotional content should usually be skipped
- Factor in relationship strength when making decisions

Provide your reasoning clearly and be consistent in your analysis."""


def create_classification_prompt(email_request: EmailProcessingRequest) -> str:
    """Create a classification prompt for Qwen 2.5"""
    
    # Build context string
    context_parts = [f"Sender: {email_request.sender}"]
    
    if email_request.subject:
        context_parts.append(f"Subject: {email_request.subject}")
    
    if email_request.contact_history:
        ch = email_request.contact_history
        context_parts.append(
            f"Contact History: {ch.total_emails} total emails, "
            f"{ch.recent_emails} recent, relationship strength {ch.relationship_strength:.2f}"
        )
    
    context = "\n".join(context_parts)
    
    return f"""
{context}

Email Content:
{email_request.content}

Classify this email with detailed multi-dimensional analysis. Consider the sender's history and relationship context in your assessment.
"""